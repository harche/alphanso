You are helping resolve merge conflicts during a Kubernetes rebase from OpenShift release branch 'release-4.22' to upstream Kubernetes tag 'v1.35.0-alpha.2'.

CONTEXT:
- 2/3 of conflicts typically stem from go.mod/go.sum files (resolve deterministically by accepting upstream changes)
- Most remaining conflicts are vendor/generation conflicts
- Few cases require manual intervention for conflicting business logic

# OPENSHIFT COMMIT CONVENTIONS:
# - UPSTREAM: <carry>: Changes we maintain in OpenShift that aren't yet upstream (preserve these)
# - UPSTREAM: <drop>: Changes being removed/discarded (no longer needed or integrated upstream)
# When resolving conflicts, preserve <carry> changes and understand that <drop> commits indicate intentional removal.

# CONFLICT VISUALIZATION SETUP:
# Ensure git is configured with: git config merge.conflictstyle diff3
# This shows three sections: HEAD (ours), base (original), MERGE_HEAD (theirs)
# Seeing the base helps understand what BOTH sides changed, not just the difference.

INVESTIGATIVE TOOLS - Use git and gh commands to understand changes:

AVAILABLE TOOLS:
- git: Use for examining commits, blame, history, diffs
  Run 'git --help' or 'git <command> --help' to learn usage
- gh: GitHub CLI for finding and viewing PRs
  Run 'gh --help', 'gh pr --help', 'gh pr list --help', etc. to learn usage

INVESTIGATION WORKFLOW (Commit -> PR -> Context):
When you encounter a complex code conflict:
1. Use 'git blame <file>' to find which commit introduced the conflicting lines
2. # Check commit messages (git log) for <carry> and <drop> tags to understand OpenShift's intent
3. # Use 'git log --oneline HEAD..MERGE_HEAD' to see upstream commits being merged in
4. # Use 'git log --oneline MERGE_HEAD..HEAD' to see OpenShift commits that might conflict
5. Use 'gh pr list' to search for PRs containing that commit hash
   - Search in both repos: kubernetes/kubernetes and openshift/kubernetes
   - Use --help to learn search options if needed
6. Use 'gh pr view' to read the PR description and understand the motivation
7. Use 'git show' or 'git log' to view commit details if needed
8. Make informed merge decisions based on understanding WHY both changes were made

KEY PRINCIPLES:
- If unsure about command syntax, use --help to check available options
- Investigate complex code conflicts (not go.mod/vendor/generated files)
- Determine if OpenShift changes are workarounds, features, or fixes
- Preserve important OpenShift customizations while accepting upstream improvements

# CONFLICT RESOLUTION ORDER (resolve in this sequence for best results):
# 1. FIRST: Dependency files (go.mod, go.sum) - Accept upstream, deterministic
# 2. SECOND: Generated files (zz_generated.*, *.pb.go, api/openapi-spec/) - Will be regenerated
# 3. THIRD: Vendored dependencies (vendor/) - Will be regenerated by hack/update-vendor.sh
# 4. FOURTH: Build/tooling files (Makefile, hack/, scripts/) - Check if OpenShift customizations still needed
# 5. FIFTH: OpenShift-specific files (openshift-hack/, OWNERS) - Always preserve OpenShift changes
# 6. LAST: Core business logic (pkg/, cmd/, staging/) - Requires careful investigation
# RATIONALE: Resolving easy→hard minimizes cascading conflicts and provides clean foundation.

# SEMANTIC CONFLICT DETECTION (check after resolving textual conflicts):
# 1. API Changes: Do both sides modify same API differently? (signatures, types, compatibility)
# 2. Behavior Changes: Do both sides change same behavior? (features, bug fixes, expectations)
# 3. Dependency Conflicts: Do both sides require different versions? (go.mod, transitive deps)
# 4. Build Conflicts: Do both sides modify build differently? (Makefile, flags, tool versions)
# VALIDATION: Run tests to catch semantic conflicts that passed textual merge but break functionality.

YOUR TASK:
0. Assess conflict complexity:
   - Count conflicted files and categorize (go.mod/vendor/generated/code)
   - Simple (<10 files, mostly deps): Quick resolution, accept upstream
   - Moderate (10-30 files, mixed): Categorize first, investigate code conflicts
   - Complex (30-50 files, many code): Careful investigation, consider manual help
   - Critical (50+ files): STOP and consult team
1. Identify all conflicted files using 'git status'
2. Resolve conflicts following these guidelines:
   - go.mod/go.sum: Accept upstream changes (<<<<<<< HEAD sections), then run 'go mod tidy'
   - vendor/: Usually generated, will be regenerated later - prefer upstream version
   - Generated files: Prefer upstream version
   - OpenShift-specific files (openshift-hack/, OWNERS, etc.): Preserve OpenShift changes
   - Code conflicts:
     * First, investigate using git and gh commands (use --help if unsure of syntax)
     * Understand the intent behind both changes by finding related commits and PRs
     * Merge carefully, preserving OpenShift customizations while accepting upstream improvements
     * Document your reasoning if you make a non-obvious choice
3. Stage all resolved files with 'git add <file>'

# IMPORTANT: Do NOT run 'go mod tidy', 'hack/install-etcd.sh', 'hack/update-vendor.sh', 'make update', 'make', or 'make test' manually.
# These will be run automatically in a container with the correct Go version and tools after you finish (etcd will be installed automatically).
#
# Do NOT edit files in the vendor/ directory manually. These are generated files that will be regenerated by hack/update-vendor.sh.
#
# VENDOR FILE CONFLICTS - Special handling required:
# When vendor/ code is incompatible or causing build/test failures:
# 1. DO NOT edit vendor/ files directly (they will be regenerated)
# 2. Check if go.mod needs updating to newer version of the dependency
# 3. Or add 'replace' directive in go.mod to use patched fork
# 4. Or modify the calling code (non-vendor files) to use different/compatible API
# 5. If truly stuck, document the issue and continue with other conflicts - mark for manual review
#
# Do NOT commit anything. Just resolve conflicts and stage the resolved files.

COMMON BUILD ERROR PATTERNS:
- \"undefined: SomeType\" → Type moved/renamed (search: git grep \"type SomeType\" MERGE_HEAD)
- \"cannot use X as Y\" → Function signature changed (compare signatures)
- \"package X not in GOROOT\" → Vendor mismatch (re-run: go mod tidy)
- \"missing go.sum entry\" → go.mod/go.sum out of sync (always run: go mod tidy)

Check if current failure matches a pattern above, then apply fix strategy.

Follow: git blame -> gh pr list (search commit) -> gh pr view (understand context) -> informed decision

Please analyze the failure above and try a different approach to resolve the conflicts.
Remember to:
1. Check 'git status' for remaining conflicts
2. For complex code conflicts, use git blame/log and gh commands to understand context
3. Resolve all conflicts carefully
4. Stage resolved files with 'git add <file>'

